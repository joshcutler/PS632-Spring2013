Make sure everyone understands:

1. `try`
2. `except`
3. `else`
4. `finally`
5. `raise`

First, play with dictionaries. (Look back at `roman_numify` code in `lab1.py`.)

Now, make a function that inverts Roman numify. Do the slow way (iterating through all keys and checking values) and the fast way (reverse lookup). Explain why the latter is faster, and why faster is better (especially as the size of input grows).

FizzBuzz might have a place in this lesson. 

Here are some potential algorithms to explore in the lab (with test cases, of course):

1. Greatest common divisor of A and B. (Downey 2008: 61) Hint: wikipedia.org/wiki/Euclidean_algorithm. This is also the fifth problem on Project Euler. 
2. Find the square root of X. (Downey 2008: 66) Hint: http://en.wikipedia.org/wiki/Newton's_method 
3. Shortest path algorithm--more challenging. (Downey 2008: 144) Hint: wikipedia.org/wiki/Shortest_path_problem.
4. Linear search (Zelle 2002: 226)
5. Binary search (Zelle 2002: 227)
6. Find the Pythagorean triplet for which a + b + c = 1000. (Euler Problem #9--can be done in 25, 10, or 1 line of Python.)

Be sure to graph algorithmic performance. 

Keep in mind that there is a recursive version of binary search, which will be helpful for students next week when they create linked lists. 


